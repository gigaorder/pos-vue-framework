<script>
  import _ from 'lodash'
  import { generateGridCSS, parseLayoutJsonObject, parseLayoutStr } from './logic/GGridGeneratorUtil'
  import { onMounted, onUpdated, reactive } from '@vue/composition-api'
  import GGridGenerator from './GGridGenerator';
  import GDialog from '../GDialog/GDialog'

  let gridLayoutInstanceCounter = 0

  export default {
    name: 'GGridLayout',
    components: { GGridGenerator, GDialog },
    props: {
      // layout object generated by grid generator
      layout: [String, Object],
      // boolean value indicate that backgroundColor of grid generator will be applied for grid layout
      displayPreviewColor: Boolean,
      // Allow hide or show grid layout editor
      editable: {
        type: Boolean,
        default: true
      },
    },
    setup(props, context) {
      const layout = (typeof(props.layout) === 'string') ? parseLayoutStr(props.layout) : parseLayoutJsonObject(props.layout)

      // vue template ref id
      const refIdWrapperElement = 'el'

      // a unique uid for scoped stylesheet of grid layout instance
      const uid = 'data-g-grid-layout-' + (gridLayoutInstanceCounter++)

      const addAreaClassForPredefinedArea = () => {
        // assign class for pre-defined area
        const wrapperEl = context.refs[refIdWrapperElement]
        const areaNodes = wrapperEl.querySelectorAll(`[area]`)
        _.each(areaNodes, node => node.classList.add(node.getAttribute('area')))

        // bring editor out of grid layout
        props.editable && wrapperEl.parentNode.appendChild(context.refs[refIdEditor])
      }


      // state
      const refIdEditor = 'editor'
      const dialogState = reactive({ show: false })
      function renderEditDialog() {
        const editDialogActivatorStyle = {
          position: 'fixed',
          top: '5px',
          right: '5px'
        }
        const editorDialogStyle = {
          display: 'flex',
          flexDirection: 'column',
          width: '100%',
          height: "100vh",
          padding: "20px",
          backgroundColor: "white",
          border: '1px solid black'
        }

        return <div ref={refIdEditor}>
          <button vOn:click={() => dialogState.show = true} style={editDialogActivatorStyle}>Open Editor</button>
          <g-dialog value={dialogState.show} persistent fullscreen>
            <div style={editorDialogStyle}>
              <div style="display: flex; flex-direction: row; padding: 10px;">
                <span style="flex: 1;">Layout editor</span>
                <button vOn:click={() => dialogState.show = false}>x</button>
              </div>
              <g-grid-generator layout={layout} style="flex: 1"/>
            </div>
          </g-dialog>
        </div>
      }

      onMounted(() => addAreaClassForPredefinedArea())
      onUpdated(() => addAreaClassForPredefinedArea())

      // try to find pre-defined VNode in default slot of gridLayout
      function _findVnodeInSlot(name) {
        return _.find(context.slots.default(), slot => {
          return slot && slot.data && slot.data.attrs && slot.data.attrs['area'] === name
        })
      }

      function processLayout(model) {
        // find a pre-defined Vnode in default slot, if default slot doesn't include current name
        // then add new div wrapper
        let vNode = _findVnodeInSlot(model.name)
        if (!vNode) {
          // assign model class to vnode
          const attrs = { class: model.name }
          let refWrapper = null
          let styleEl = null
          let dialogEdit = null
          // assign stuff if model is root node
          if (!model.parent) {
            attrs[uid] = ''
            refWrapper = { ref : refIdWrapperElement }
            styleEl = <style type="text/css">
              {generateGridCSS(layout, uid, { showBackgroundColor: props.displayPreviewColor })}
            </style>
            dialogEdit = props.editable ? renderEditDialog() : null
          }
          vNode = <div {...{ attrs }} {...refWrapper}>
            {styleEl}
            {dialogEdit}
            {_.map(model.subAreas, processLayout)}
          </div>
        }

        return vNode
      }

      return function() {
        return processLayout(layout)
      }
    }
  }
</script>
